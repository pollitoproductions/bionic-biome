<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no,viewport-fit=cover">
<meta name="description" content="Bionic Biome - A cyberpunk action game with roguelike elements">
<meta name="author" content="Brant Fuller">
<meta name="theme-color" content="#000000">
<title>Bionic Biome v1.0 © 2026</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden; background: #000;
    touch-action: none; font-family: 'Courier New', sans-serif;
    width: 100vw; height: 100vh;
    display: flex; justify-content: center; align-items: center;
    color: white;
  }
  canvas {
    display: block; max-width: 100%; max-height: 100%;
    object-fit: contain; background: #000;
    image-rendering: pixelated; 
  }
  #ui-layer {
    position: fixed; left: 0; top: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 100;
    user-select: none; -webkit-user-select: none;
  }
  /* Virtual Joystick */
  .joy-container {
    position: absolute; left: 5%; bottom: 8%; width: 140px; height: 140px;
    background: rgba(255,255,255,0.06); border-radius: 50%;
    pointer-events: auto; border: 2px solid rgba(0,255,255,0.06);
  }
  .knob {
    position: absolute; left: 45px; top: 45px; width: 50px; height: 50px;
    background: #fff; border-radius: 50%; pointer-events: none;
  }
/* Action Button - no text, subtle shaded look with glossy overlay */
.btn-action {
  position: absolute;
  right: 5%;
  bottom: 8%;
  width: 100px;
  height: 100px;
  background: linear-gradient(180deg, rgba(50,50,50,0.5), rgba(30,30,30,0.7));
  border-radius: 50%;
  pointer-events: auto;
  border: 2px solid rgba(100,100,100,0.3);
  display: flex;
  align-items: center;
  justify-content: center;
  color: #fff;
  font-weight: bold;
  font-size: 16px;
  text-align: center;
  box-shadow: inset 0 -10px 20px rgba(0,0,0,0.6), 0 6px 10px rgba(0,0,0,0.6);
  transition: transform 0.08s;
  overflow: hidden; /* clips the glossy overlay */
}
.btn-action:active { transform: translateY(3px); }

/* subtle top-to-bottom glossy shade over the action button */
.btn-action::after {
  content: "";
  position: absolute;
  inset: 0;
  border-radius: 50%;
  pointer-events: none;
  background: linear-gradient(
    180deg,
    rgba(255,255,255,0.12) 0%,
    rgba(255,255,255,0.05) 30%,
    rgba(255,255,255,0.02) 60%,
    rgba(255,255,255,0) 100%
  );
  mix-blend-mode: overlay;
  z-index: 2;
}

/* small glossy highlight near top-left for extra depth */
.btn-action::before {
  content: "";
  position: absolute;
  left: 12%;
  top: 10%;
  width: 36%;
  height: 30%;
  border-radius: 50%;
  pointer-events: none;
  background: radial-gradient(closest-side, rgba(255,255,255,0.25), rgba(255,255,255,0) 60%);
  mix-blend-mode: screen;
  z-index: 3;
}

  /* SCREENS */
  .screen-overlay {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.85);
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 200; pointer-events: auto;
    backdrop-filter: blur(4px);
  }
  
  h1 { 
    margin: 0 0 10px 0; 
    font-family: 'Press Start 2P', cursive; 
    font-size: 28px; 
    text-shadow: 4px 4px 0px #3498db; 
    color: #fff; 
    text-align: center; 
    line-height: 1.4;
  }
  
  .author-sub {
    font-size: 10px; color: #aaa; margin-bottom: 25px; text-align: center; line-height: 1.6;
    font-family: 'Press Start 2P', cursive;
    max-width: 90%;
  }

  /* STATS BOX (slightly larger to avoid overlap) */
  .stats-box {
    background: rgba(0, 0, 0, 0.7);
    padding: 15px 22px; 
    border-radius: 6px; 
    border: 2px solid rgba(255,255,255,0.08);
    width: 380px; 
    text-align: left; 
    margin-bottom: 15px;
    font-family: 'Press Start 2P', cursive; 
  }
  .stat-row { 
    display: flex; justify-content: space-between; 
    margin-bottom: 8px; font-size: 10px; 
    line-height: 1.2; color: #eee;
  }
  .stat-row:last-child { margin-bottom: 0; }
  .stat-label { color: #aaa; }
  .stat-val { color: #fff; }

  /* BUTTONS */
  .btn-row {
    display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;
  }
  .btn-std {
    background: linear-gradient(180deg,#00e6ff,#0077aa);
    color: #000; border: none;
    padding: 12px 18px; font-size: 13px; 
    font-weight: bold; border-radius: 6px; 
    cursor: pointer;
    box-shadow: 0 6px 0px #003f4d, 0 0 18px rgba(0,230,255,0.08);
    transition: transform 0.08s, box-shadow 0.12s;
    font-family: 'Press Start 2P', cursive; 
    text-transform: uppercase;
    margin: 5px;
    pointer-events: auto;
  }
  .btn-std:active { transform: translateY(4px); box-shadow: none; }

  .btn-menu { background: linear-gradient(90deg,#9b59b6,#3498db); color: #fff; box-shadow: 0 6px 0px rgba(20,20,40,0.7); }

  /* DIFFICULTY BUTTONS - updated to match menu visual style */
  .btn-easy {
    background: linear-gradient(90deg,#2ecc71,#27ae60);
    color: #001218;
    box-shadow: 0 10px 40px rgba(0,150,255,0.06);
    border: 2px solid rgba(0,200,255,0.14);
  }
  .btn-moderate {
    background: linear-gradient(90deg,#f1c40f,#d4ac0d);
    color: #001218;
    box-shadow: 0 10px 40px rgba(0,150,255,0.06);
    border: 2px solid rgba(0,200,255,0.14);
  }
  .btn-hard {
    background: linear-gradient(90deg,#e74c3c,#c0392b);
    color: #001218;
    box-shadow: 0 10px 40px rgba(0,150,255,0.06);
    border: 2px solid rgba(0,200,255,0.14);
  }

  /* Cyberpunk menus */
  .menu-box {
    background: linear-gradient(180deg, rgba(6,6,12,0.96), rgba(18,6,34,0.96));
    border: 2px solid rgba(0, 200, 255, 0.14);
    padding: 0; width: 90%; max-width: 420px;
    text-align: center; font-family: 'Press Start 2P', cursive;
    overflow: hidden;
    display: flex; flex-direction: column;
    box-shadow: 0 10px 40px rgba(0,150,255,0.06);
    border-radius: 8px;
  }
  .menu-tabs {
    display: flex; border-bottom: 1px solid rgba(0,200,255,0.06);
    background: linear-gradient(90deg, rgba(0,0,0,0.18), rgba(0,30,60,0.18));
  }
  .menu-tab {
    flex: 1; background: transparent; color: #9fbcd3; cursor: pointer;
    padding: 14px 0; font-size: 12px; border: none; font-family: 'Press Start 2P', cursive;
    position: relative;
  }
  .menu-tab.active {
    color: #00e6ff;
    box-shadow: inset 0 -4px 0 rgba(0,230,255,0.12);
  }

  .menu-content { padding: 18px; min-height: 200px; color:#cfeff6; font-size:13px; }
  .track-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px; margin: 10px 0; }
  .track-btn {
    background: linear-gradient(180deg,#14121a,#1f1b29); border: 1px solid rgba(0,200,255,0.06); color: #9fbcd3;
    padding: 10px 4px; cursor: pointer; font-size: 12px; border-radius: 6px;
    font-family: 'Press Start 2P', cursive;
    transition: box-shadow 0.12s, transform 0.06s;
    box-shadow: 0 2px 0 rgba(0,0,0,0.7);
  }
  .track-btn.active, .track-btn:hover { box-shadow: 0 6px 24px rgba(0,230,255,0.12); color:#00e6ff; transform: translateY(-2px); border-color: rgba(0,230,255,0.18); }

  .mode-switch { display: flex; justify-content: center; gap: 10px; margin-bottom: 10px; }
  .switch-btn {
    background: #1a1a2b; padding: 8px 15px; cursor: pointer; font-size: 12px; border: 1px solid rgba(255,255,255,0.04);
    color: #9fbcd3; border-radius: 6px;
  }
  .switch-btn.selected { background: #00e6ff; color: #001218; box-shadow: 0 6px 20px rgba(0,230,255,0.14); }

  /* TIPS LIST */
  .tips-list {
    text-align: left; font-size: 12px; line-height: 1.8; color: #cfeff6;
  }
  .tips-list li { margin-bottom: 10px; }

  .btn-close {
    background: linear-gradient(90deg,#ff4d4d,#c0392b); color: white; border: none; padding: 10px 20px;
    margin: 15px; cursor: pointer; font-family: 'Press Start 2P', cursive;
    box-shadow: 0 6px 0 rgba(150,20,20,0.7); align-self: center; border-radius:6px;
  }
  .btn-close:active { transform: translate(0,4px); box-shadow: none; }

  /* VICTORY SPECIFIC */
  .victory-title { color: #f1c40f; text-shadow: 4px 4px 0px #e67e22; margin-bottom: 20px; }
  .victory-time { font-family: 'Press Start 2P', cursive; color: #fff; margin-bottom: 30px; font-size: 14px; text-align: center; line-height: 1.6; }
  
  .hidden { display: none !important; }

  /* PAUSE OVERLAY */
  #pause-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 150;
    pointer-events: none;
  }
  .pause-text {
    font-family: 'Press Start 2P', cursive;
    font-size: 15px;
    color: #00e6ff;
    text-align: center;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
    padding: 20px;
    line-height: 1.6;
  }

  /* === Responsive fixes (added per request) === */
  * { box-sizing: border-box; }

  /* Respect safe area insets (notches) and provide padding for overlays */
  .screen-overlay {
    padding: env(safe-area-inset-top,20px) env(safe-area-inset-right,20px) env(safe-area-inset-bottom,20px) env(safe-area-inset-left,20px);
    box-sizing: border-box;
  }

  /* Make menu box and stats box responsive and scrollable if tall */
  .menu-box,
  .stats-box,
  .menu-content {
    width: min(92vw, 420px);
    max-width: 92vw;
    max-height: calc(100vh - 96px);
    overflow: auto;
  }

  /* Limit tips panel height so list scrolls rather than pushing off bottom */
  #panel-tips {
    max-height: calc(60vh);
    overflow-y: auto;
    padding-right: 8px;
  }

  /* Ensure victory screen content wraps and fits horizontally */
  .victory-time,
  .author-sub,
  .menu-content,
  .stats-box .stat-row {
    word-wrap: break-word;
    hyphens: auto;
  }

  /* Make the "SELECT DIFFICULTY" area responsive */
  #diff-btns { gap: 8px; justify-content: center; padding: 6px; }

  /* Prevent horizontal overflow */
  html, body {
    overflow-x: hidden;
  }

  /* Small devices: reduce large fonts so screens fit */
  @media (max-width: 420px) {
    h1 { font-size: 20px; }
    .victory-time { font-size: 12px; }
    .btn-std { padding: 10px 12px; font-size: 11px; }
    .stats-box { padding: 10px; }
  }

</style>
</head>
<body>

<canvas id="c" width="800" height="600"></canvas>

<div id="ui-layer">
  <div class="joy-container" id="joy"><div class="knob" id="knob"></div></div>
  <!-- action button text removed, just shaded -->
  <div class="btn-action" id="act" aria-label="attack button"></div>
</div>

<div id="start-screen" class="screen-overlay">
  <h1 id="title-text">BIONIC<br>BIOME</h1>
  
  <div class="author-sub">Created by Brant Fuller &copy; 2026<br>All Rights Reserved.</div>

  <div class="stats-box" id="stats-box" style="display:none;">
    <div class="stat-row"><span class="stat-label">BIOME REACHED:</span> <span class="stat-val" id="st-biome">1</span></div>
    <div class="stat-row"><span class="stat-label">ENEMIES DEFEATED:</span> <span class="stat-val" id="st-kills">0</span></div>
    <div class="stat-row"><span class="stat-label">TIME LASTED:</span> <span class="stat-val" id="st-time">00:00</span></div>
    <div class="stat-row"><span class="stat-label">HP COLLECTED:</span> <span class="stat-val" id="st-hearts">0</span></div>
    <div class="stat-row"><span class="stat-label">SWORD LEVEL:</span> <span class="stat-val" id="st-sword">1</span></div>
    <div class="stat-row"><span class="stat-label">BOW LEVEL:</span> <span class="stat-val" id="st-bow">1</span></div>
    <div class="stat-row"><span class="stat-label">DIFFICULTY:</span> <span class="stat-val" id="st-diff">CASUAL</span></div>
  </div>
  
  <div class="btn-row" id="main-btns">
    <button class="btn-std btn-menu" id="menu-btn">MENU</button>
    <button class="btn-std" id="play-btn">PLAY</button>
  </div>

  <div class="btn-row hidden" id="diff-btns">
    <div style="width:100%; text-align:center; margin-bottom:10px; font-family:'Press Start 2P'; font-size:12px; color:#aaa;">SELECT DIFFICULTY</div>
    <button class="btn-std btn-easy" onclick="selectDifficulty('easy')">CASUAL</button>
    <button class="btn-std btn-moderate" onclick="selectDifficulty('moderate')">MODERATE</button>
    <button class="btn-std btn-hard" onclick="selectDifficulty('impossible')">IMPOSSIBLE</button>

    <!-- Tip added per request: tell player how to pause/unpause using the map -->
    <div style="width:100%; text-align:center; margin-top:12px; font-family:'Press Start 2P'; font-size:11px; color:#00e6ff; max-width:360px;">
      PAUSE GAME BY TOUCHING MAP IN TOP RIGHT
    </div>
  </div>
</div>

<div id="menu-screen" class="screen-overlay hidden">
  <div class="menu-box">
    <div class="menu-tabs">
      <button class="menu-tab active" id="tab-sound">SOUND</button>
      <button class="menu-tab" id="tab-tips">TIPS</button>
    </div>
    
    <div class="menu-content" id="panel-sound">
       <div class="mode-switch">
         <div class="switch-btn selected" id="sw-biome">BIOME</div>
         <div class="switch-btn" id="sw-dungeon">DUNGEON</div>
       </div>
       <div class="track-grid" id="track-grid">
         </div>
    </div>

    <div class="menu-content hidden" id="panel-tips">
      <ul class="tips-list">
        <li>&gt; Enemies do 50% more damage if your back is turned.</li>
        <li>&gt; Enemies and Bosses scale infinitely.</li>
        <li>&gt; Defeating the Biome 10 Boss wins the run.</li>
        <li>&gt; Hold Attack to fire arrows.</li>
        <li>&gt; Mark the entrance to the dungeon on the map by moving close to it.</li>
      </ul>
    </div>

    <button class="btn-close" id="close-menu-btn">BACK</button>
  </div>
</div>

<div id="victory-screen" class="screen-overlay hidden">
  <h1 class="victory-title">CONGRATULATIONS!</h1>
  <div class="victory-time">
    YOU HAVE DEFEATED THE<br>INFERNO BOSS!<br><br>
    OFFICIAL TIME:<br>
    <span id="victory-time-display" style="color:#2ecc71; font-size: 20px;">00:00</span>
  </div>
  <button class="btn-std" id="continue-btn">CONTINUE</button>
</div>

<div id="pause-overlay" class="hidden">
  <div class="pause-text">TOUCH MAP IN TOP RIGHT TO RESUME</div>
</div>

<script>
/**
 * BIONIC BIOME v1.0
 *
 * Changes implemented in this version:
 * - Beginner (was Easy) naming in UI and stats.
 * - Beginner mode: triple drop chances (hp, sword, bow).
 * - Pause when menu shown or page/backgrounded; minimap toggles Pause/Unpause.
 * - Responsive CSS adjustments so tips and end-of-run screens don't spill off small screens.
 * - MAX_HP constant added and used to initialize player.max (set to 9,999,999).
 */

/* === CONFIG / CONSTANTS (unchanged semantics) === */
const TILE = 32;
const MAP_SIZE = 120; 
const WORLD = MAP_SIZE * TILE;
const MAX_HP = 9999999; // new max HP constant per request

// GAME STATE
let gameActive = false;      // when true, update(dt) runs and input works
let gameRunning = false;     // marks that a run is in-progress (used to allow pause/resume)
let gameOver = false;
let biomeLevel = 1;
let inDungeon = false;
let currentDifficulty = 'easy'; // remains the key; displayed name will be "CASUAL"

let wasActiveBeforePause = false;
let pauseTimestamp = 0;
let savedMusicTrack = null; // Track what music was playing before pause

const DIFFICULTY_SETTINGS = {
  easy: {
    name: "CASUAL",
    enemySpeedStep: 0.08,
    enemyCountBase: 200,
    enemyCountStep: 36,
    bossHpMult: 360,
    bossDefMult: 0.3,
    bossSpeedAdd: 0
  },
  moderate: { 
    name: "MODERATE",
    enemySpeedStep: 0.15,
    enemyCountBase: 200,
    enemyCountStep: 60,
    bossHpMult: 600,
    bossDefMult: 0.5,
    bossSpeedAdd: 0
  },
  impossible: { 
    name: "IMPOSSIBLE",
    enemySpeedStep: 0.22,
    enemyCountBase: 300,
    enemyCountStep: 85,
    bossHpMult: 840,
    bossDefMult: 0.7,
    bossSpeedAdd: 1.0
  }
};

// These original constants remain the same in numeric value but we'll derive per-second velocities below.
const PLAYER_SPEED = 4.5;   // originally px/frame
const BOSS_SPEED = 2.5;     // originally px/frame
const PLAYER_RAD = 18;      // unchanged

// ARROW: restored original per-frame number (13). We'll convert to per-second below.
const ARROW_BASE_SPEED = 13; // px/frame originally

// Fire interval in ms (unchanged)
const FIRE_INTERVAL_MS = 100;

/* === DELTA-TIME PREPARATION ===
   The game historically used values in px/frame. We'll treat those "per-frame" numbers as if they were for 60 FPS,
   and convert them to per-second velocities by multiplying by 60 (frames/sec). During update, we multiply per-second
   velocities by dt (seconds since last frame).
*/
const FPS = 60;
const PLAYER_SPEED_PPS = PLAYER_SPEED * FPS;      // px per second
const BOSS_SPEED_PPS = BOSS_SPEED * FPS;          // px per second
const ARROW_SPEED_PPS = ARROW_BASE_SPEED * FPS;   // px per second

/* === STATE === */
let startTime = 0;
let enemiesKilled = 0;
let heartsCollected = 0;
let beatGameTime = null;

let player, world;
let shots = [];
let drops = [];
let explored = [];

/* Flow-field timing: previously used a frame counter flowTimer++ and ran updateFlowField when >15.
   15 frames at 60FPS is 0.25s (I use 0.2667 earlier — keep similar). Use a seconds accumulator now.
*/
let flowMap = []; 
let flowAccSeconds = 0; // accumulate seconds to trigger flow updates

/* --- SOUND / MUSIC (unchanged) --- */
const Music = {
  ctx: null, osc: null, gain: null, timer: null, isPlaying: false, currentTrackId: null,
  init() { if (!this.ctx) { const AudioContext = window.AudioContext || window.webkitAudioContext; this.ctx = new AudioContext(); } if (this.ctx.state === 'suspended') this.ctx.resume(); },
  playSFX(type){ if(!this.ctx) return; const t=this.ctx.currentTime; const osc=this.ctx.createOscillator(); const gain=this.ctx.createGain(); const mod=this.ctx.createOscillator(); const modGain=this.ctx.createGain(); osc.connect(gain); gain.connect(this.ctx.destination); mod.connect(modGain); modGain.connect(osc.frequency); if(type==='start'){ osc.type='square'; osc.frequency.setValueAtTime(110,t); osc.frequency.exponentialRampToValueAtTime(880,t+0.3); mod.type='sawtooth'; mod.frequency.setValueAtTime(50,t); mod.frequency.linearRampToValueAtTime(200,t+0.3); modGain.gain.setValueAtTime(500,t); gain.gain.setValueAtTime(0.2,t); gain.gain.linearRampToValueAtTime(0,t+0.3); osc.start(t); mod.start(t); osc.stop(t+0.3); mod.stop(t+0.3);} else if(type==='gameover'){ osc.type='sawtooth'; osc.frequency.setValueAtTime(400,t); osc.frequency.exponentialRampToValueAtTime(40,t+1.0); mod.type='square'; mod.frequency.setValueAtTime(60,t); mod.frequency.linearRampToValueAtTime(10,t+1.0); modGain.gain.setValueAtTime(1000,t); gain.gain.setValueAtTime(0.3,t); gain.gain.exponentialRampToValueAtTime(0.001,t+1.0); osc.start(t); mod.start(t); osc.stop(t+1.0); mod.stop(t+1.0);} },
  generateDarkTrack(level,isDungeon){ const roots=[110,130.81,146.83,164.81,174.61]; let base=roots[(level-1)%roots.length]; let p=(level-1)%3, notes=[], intervals=[]; if(isDungeon){ base*=0.5; intervals=[0,0,6,0,7,6,13,0]; } else { if(p===0) intervals=[0,3,7,12,0,3,7,12,0,0,12,12,7,7,3,3]; else if(p===1) intervals=[0,0,12,0,3,0,12,0,7,0,12,0,5,0,12,0]; else intervals=[0,1,0,1,5,7,5,7,12,1,12,1,0,0,12,0]; } for(let i=0;i<intervals.length;i++){ notes.push(base*Math.pow(2,intervals[i]/12)); } return {notes, bpm: isDungeon?90+level:125+level*2}; },
  play(type,override){ let lvl=override||biomeLevel; let id=type; if(type==='overworld'||type==='dungeon') id=type+'_'+lvl; if(this.currentTrackId===id && this.isPlaying) return; this.stop(); this.init(); this.currentTrackId=id; this.isPlaying=true; let td=null; if(type==='title') td={bpm:180,notes:[261,523,392,329,261,523,493,392],loop:true}; else if(type==='victory') td={bpm:120,notes:[261,392,523,659,783,1046,0],loop:false}; else if(type==='overworld'){ td=this.generateDarkTrack(lvl,false); td.loop=true; } else if(type==='dungeon'){ td=this.generateDarkTrack(lvl,true); td.loop=true; } if(!td) return; this.osc=this.ctx.createOscillator(); this.gain=this.ctx.createGain(); this.osc.type='sawtooth'; this.osc.connect(this.gain); this.gain.connect(this.ctx.destination); this.gain.gain.setValueAtTime(0,this.ctx.currentTime); this.osc.start(); let idx=0; const next=()=>{ if(!this.isPlaying) return; let f=td.notes[idx]; const t=this.ctx.currentTime; const dur=td.bpm/1000; if(f>0){ this.osc.frequency.setValueAtTime(f,t); this.gain.gain.cancelScheduledValues(t); this.gain.gain.setValueAtTime(0.08,t); this.gain.gain.exponentialRampToValueAtTime(0.001,t+(dur*0.9)); } else { this.gain.gain.setValueAtTime(0,t); } idx++; if(idx>=td.notes.length){ if(!td.loop){ this.stop(); return; } idx=0; } this.timer = setTimeout(next, td.bpm); }; next(); },
  stop(){ this.isPlaying=false; clearTimeout(this.timer); if(this.osc){ try{ this.osc.stop(); this.osc.disconnect(); } catch(e){} this.osc=null; } this.currentTrackId=null; }
};


/* === BIOMES, UTILS, DOM (unchanged) === */
const biomes = [
  {name: "Grey Peak", grass:"#78909c", wall:"#cfd8dc", wallEdge:"#37474f", boss:"#3498db", enemy:"#f1c40f"},
  {name: "Emerald Grove", grass:"#00695c", wall:"#004d40", wallEdge:"#b2dfdb", boss:"#2ecc71", enemy:"#d500f9"}, 
  {name: "Teal Tundra", grass:"#26a69a", wall:"#80cbc4", wallEdge:"#004d40", boss:"#9b59b6", enemy:"#e91e63"}, 
  {name: "Gold Waste", grass:"#d4ac0d", wall:"#f9e79f", wallEdge:"#7d6608", boss:"#e67e22", enemy:"#8e44ad"}, 
  {name: "Azure Lake", grass:"#85c1e9", wall:"#d6eaf8", wallEdge:"#2e86c1", boss:"#fdfefe", enemy:"#d35400"}, 
  {name: "Midnight Zone", grass:"#2c3e50", wall:"#566573", wallEdge:"#17202a", boss:"#a569bd", enemy:"#e74c3c"}, 
  {name: "Mudlands", grass:"#5d4037", wall:"#8d6e63", wallEdge:"#3e2723", boss:"#e91e63", enemy:"#2ecc71"}, 
  {name: "Venom Swamp", grass:"#117a65", wall:"#48c9b0", wallEdge:"#0e6251", boss:"#f4d03f", enemy:"#ff5722"}, 
  {name: "Violet Void", grass:"#4a235a", wall:"#a569bd", wallEdge:"#150b1a", boss:"#ecf0f1", enemy:"#e74c3c"}, 
  {name: "INFERNO", grass:"#c0392b", wall:"#e6b0aa", wallEdge:"#641e16", boss:"#ff0000", enemy:"#f1c40f"}  
];

function isWall(x, y) {
  let tx = Math.floor(x / TILE);
  let ty = Math.floor(y / TILE);
  if (tx < 0 || ty < 0 || tx >= MAP_SIZE || ty >= MAP_SIZE) return true;
  return world.grid[ty][tx] === 1;
}

function findSafePos() {
  let sx, sy;
  do {
    sx = Math.random() * WORLD;
    sy = Math.random() * WORLD;
  } while (isWall(sx, sy));
  return {x: sx, y: sy};
}

function vibrate(ms) {
  if (window.navigator && window.navigator.vibrate) {
    window.navigator.vibrate(ms);
  }
}

function formatTime(ms) {
  let s = Math.floor(ms / 1000);
  let m = Math.floor(s / 60);
  s = s % 60;
  return (m < 10 ? "0"+m : m) + ":" + (s < 10 ? "0"+s : s);
}

/* DOM elements (unchanged) */
const startScreen = document.getElementById('start-screen');
const menuScreen = document.getElementById('menu-screen');
const victoryScreen = document.getElementById('victory-screen');
const statsBox = document.getElementById('stats-box');
const playBtn = document.getElementById('play-btn');
const menuBtn = document.getElementById('menu-btn');
const closeMenuBtn = document.getElementById('close-menu-btn');
const continueBtn = document.getElementById('continue-btn');
const titleText = document.getElementById('title-text');
const victoryTimeDisplay = document.getElementById('victory-time-display');

const mainBtns = document.getElementById('main-btns');
const diffBtns = document.getElementById('diff-btns');

const tabSound = document.getElementById('tab-sound');
const tabTips = document.getElementById('tab-tips');
const panelSound = document.getElementById('panel-sound');
const panelTips = document.getElementById('panel-tips');
const trackGrid = document.getElementById('track-grid');
const swBiome = document.getElementById('sw-biome');
const swDungeon = document.getElementById('sw-dungeon');

const elBiome = document.getElementById('st-biome');
const elKills = document.getElementById('st-kills');
const elHearts = document.getElementById('st-hearts'); 
const elTime = document.getElementById('st-time');
const elSword = document.getElementById('st-sword');
const elBow = document.getElementById('st-bow');
const elDiff = document.getElementById('st-diff');

/* === PAUSE/RESUME HELPERS === */
function pauseGame(showOverlay = true) {
  // Record whether the game was active so we can resume later
  wasActiveBeforePause = gameActive;
  if (gameActive) {
    stopAction();
    // Record when we paused to adjust startTime on resume
    pauseTimestamp = Date.now();
    // Save current music state and stop music
    savedMusicTrack = Music.currentTrackId;
    Music.stop();
  }
  gameActive = false;
  
  // Show overlay if requested (not shown for menu pause)
  if (showOverlay) {
    document.getElementById('pause-overlay').classList.remove('hidden');
  }
}

function resumeGame() {
  // Hide pause overlay
  document.getElementById('pause-overlay').classList.add('hidden');
  
  // Adjust startTime to freeze the clock during pause
  if (pauseTimestamp > 0) {
    const pausedDuration = Date.now() - pauseTimestamp;
    startTime += pausedDuration;
    pauseTimestamp = 0;
  }
  
  // Resume music if it was playing before pause
  if (savedMusicTrack && !gameOver && gameRunning) {
    if (savedMusicTrack.startsWith('overworld_')) {
      Music.play('overworld');
    } else if (savedMusicTrack.startsWith('dungeon_')) {
      Music.play('dungeon');
    }
    savedMusicTrack = null;
  }
  
  // Resume the game if a run is in progress and not ended
  if (!gameOver && gameRunning) {
    gameActive = true;
    wasActiveBeforePause = false;
  }
}

/* toggle pause/unpause via map (top-right minimap) */
function togglePauseByMap() {
  if (!gameRunning || gameOver) return;
  if (!startScreen.classList.contains('hidden')) return;

  if (gameActive) {
    pauseGame();
  } else {
    resumeGame();
  }
}

/* === EVENT LISTENERS (unchanged behavior, with pause/resume integration) === */
const initAudioInteraction = () => {
  Music.init();
  if (!gameActive && startScreen.classList.contains('hidden') === false && menuScreen.classList.contains('hidden')) {
    Music.play('title');
  }
  window.removeEventListener('click', initAudioInteraction);
  window.removeEventListener('touchstart', initAudioInteraction);
};
window.addEventListener('click', initAudioInteraction);
window.addEventListener('touchstart', initAudioInteraction);

playBtn.addEventListener('click', () => {
  mainBtns.classList.add('hidden');
  diffBtns.classList.remove('hidden');
  titleText.style.display = 'none';
  document.querySelector('.author-sub').style.display = 'none';
  statsBox.style.display = 'none';
});

window.selectDifficulty = (diff) => {
  currentDifficulty = diff;
  Music.init();
  Music.playSFX('start'); 
  setTimeout(() => {
    startGame();
  }, 450);
};

let soundTestMode = 'overworld'; 
function renderTrackButtons() {
  trackGrid.innerHTML = '';
  for(let i=1; i<=10; i++) {
    let b = document.createElement('div');
    b.className = 'track-btn';
    b.innerText = i;
    b.onclick = () => {
       document.querySelectorAll('.track-btn').forEach(btn => btn.classList.remove('active'));
       b.classList.add('active');
       Music.play(soundTestMode, i);
    };
    trackGrid.appendChild(b);
  }
}

menuBtn.addEventListener('click', () => {
  // Pause the game whenever the menu is shown
  pauseGame(false);

  Music.init();
  startScreen.classList.add('hidden');
  menuScreen.classList.remove('hidden');
  renderTrackButtons();
  tabSound.click();
});

tabSound.addEventListener('click', () => {
  tabSound.classList.add('active');
  tabTips.classList.remove('active');
  panelSound.classList.remove('hidden');
  panelTips.classList.add('hidden');
});

tabTips.addEventListener('click', () => {
  tabTips.classList.add('active');
  tabSound.classList.remove('active');
  panelTips.classList.remove('hidden');
  panelSound.classList.add('hidden');
  Music.stop(); 
  document.querySelectorAll('.track-btn').forEach(btn => btn.classList.remove('active'));
});

closeMenuBtn.addEventListener('click', () => {
  Music.stop();
  menuScreen.classList.add('hidden');
  startScreen.classList.remove('hidden');
  Music.play('title');

  // Resume the game only if it was active before the menu was opened (resumeGame checks that)
  resumeGame();
});

swBiome.addEventListener('click', () => {
  swBiome.classList.add('selected');
  swDungeon.classList.remove('selected');
  soundTestMode = 'overworld';
  document.querySelectorAll('.track-btn').forEach(btn => btn.classList.remove('active'));
  Music.stop();
});

swDungeon.addEventListener('click', () => {
  swDungeon.classList.add('selected');
  swBiome.classList.remove('selected');
  soundTestMode = 'dungeon';
  document.querySelectorAll('.track-btn').forEach(btn => btn.classList.remove('active'));
  Music.stop();
});

continueBtn.addEventListener('click', () => {
  Music.playSFX('start');
  setTimeout(() => {
    victoryScreen.classList.add('hidden');
    gameActive = true;
    gameRunning = true;
    biomeLevel++;
    generateWorld(false);
  }, 450);
});

/* === GAME START / OVER / WORLD GENERATION (unchanged semantics except mark gameRunning) === */
function showGameOver() {
  gameActive = false;
  gameOver = true;
  gameRunning = false;
  Music.playSFX('gameover');
  
  elBiome.innerText = biomeLevel;
  elKills.innerText = enemiesKilled;
  elHearts.innerText = heartsCollected;
  elTime.innerText = formatTime(Date.now() - startTime);
  elSword.innerText = player.swordLvl;
  elBow.innerText = player.bowLvl;
  elDiff.innerText = (DIFFICULTY_SETTINGS[currentDifficulty]?.name || currentDifficulty).toUpperCase();

  titleText.innerText = "RUN OVER"; 
  titleText.style.display = 'block';
  document.querySelector('.author-sub').style.display = 'block';
  
  statsBox.style.display = "block";
  
  playBtn.innerText = "RETRY";
  mainBtns.classList.remove('hidden');
  diffBtns.classList.add('hidden');
  
  startScreen.classList.remove('hidden');
}

function showVictoryScreen() {
    // When victory screen appears, pause the active play. continueBtn will resume appropriately.
    wasActiveBeforePause = gameActive;
    gameActive = false;

    Music.play('victory');
    let finalTime = Date.now() - startTime;
    victoryTimeDisplay.innerText = formatTime(finalTime);
    victoryScreen.classList.remove('hidden');
}

function startGame() {
  startScreen.classList.add('hidden');
  victoryScreen.classList.add('hidden');
  // Mark the game as logically running and active (unless another mechanism paused it)
  gameRunning = true;
  gameActive = true;
  generateWorld(true);
}

function generateWorld(reset) {
  world = { grid: [], enemies: [], entrance: {x: 0, y: 0}, boss: null };
  flowMap = Array(MAP_SIZE).fill().map(() => Array(MAP_SIZE).fill(9999));
  flowAccSeconds = 0;
  
  Music.play('overworld'); 

  let wallChance = 0.06;

  for (let y = 0; y < MAP_SIZE; y++) {
    world.grid[y] = [];
    for (let x = 0; x < MAP_SIZE; x++) {
      let isBorder = (x === 0 || y === 0 || x === MAP_SIZE - 1 || y === MAP_SIZE - 1);
      let isWallTile = isBorder || (Math.random() < wallChance);
      world.grid[y][x] = isWallTile ? 1 : 0;
    }
  }

  if (reset) {
    let sp = findSafePos();
    // use MAX_HP constant for player's max HP
    player = { x: sp.x, y: sp.y, hp: 10, max: MAX_HP, swordLvl: 1, bowLvl: 1, dir: 0, swing: 0, hitTimer: 0 };
    player.glowColor = biomes[(biomeLevel - 1) % biomes.length].boss || biomes[(biomeLevel - 1) % biomes.length].enemy;
    biomeLevel = 1;
    startTime = Date.now();
    enemiesKilled = 0;
    heartsCollected = 0;
    beatGameTime = null;
  } else {
    let sp = findSafePos();
    player.x = sp.x;
    player.y = sp.y;
    player.glowColor = biomes[(biomeLevel - 1) % biomes.length].boss || biomes[(biomeLevel - 1) % biomes.length].enemy;
  }

  shots = [];
  drops = [];
  inDungeon = false;
  gameOver = false;
  explored = Array(MAP_SIZE).fill().map(() => Array(MAP_SIZE).fill(false));

  let ep = findSafePos();
  while (Math.hypot(ep.x - player.x, ep.y - player.y) < 1500) ep = findSafePos();
  world.entrance = ep;

  let settings = DIFFICULTY_SETTINGS[currentDifficulty];  
  let scaledDmg = 1 + Math.floor((biomeLevel - 1) * 0.25);
  let enemyCount = settings.enemyCountBase + (biomeLevel * settings.enemyCountStep);

  for (let i = 0; i < enemyCount; i++) {
    let enp = findSafePos();
    if (Math.hypot(enp.x - player.x, enp.y - player.y) > 500) {
      world.enemies.push({ 
        x: enp.x, 
        y: enp.y, 
        hp: 1, 
        dmg: scaledDmg, 
        atkDelay: 0, 
        hitTimer: 0,
        color: biomes[(biomeLevel - 1) % biomes.length].enemy
      });
    }
  }
}

/* === PATHFINDING (unchanged) === */
function updateFlowField() {
  for(let y=0; y<MAP_SIZE; y++) {
    for(let x=0; x<MAP_SIZE; x++) {
      flowMap[y][x] = 9999;
    }
  }
  let pTx = Math.floor(player.x / TILE);
  let pTy = Math.floor(player.y / TILE);
  if(pTx<0 || pTy<0 || pTx>=MAP_SIZE || pTy>=MAP_SIZE) return;

  let queue = [];
  flowMap[pTy][pTx] = 0;
  queue.push({x: pTx, y: pTy});
  let visitedCount = 0;
    
  while(queue.length > 0) {
    let curr = queue.shift();
    let dist = flowMap[curr.y][curr.x];
    if(dist > 25) continue; 
    const dirs = [[0,1], [0,-1], [1,0], [-1,0]];
    for(let i=0; i<dirs.length; i++) {
      let nx = curr.x + dirs[i][0];
      let ny = curr.y + dirs[i][1];
      if(nx>=0 && ny>=0 && nx<MAP_SIZE && ny<MAP_SIZE) {
        if(world.grid[ny][nx] === 0 && flowMap[ny][nx] === 9999) {
          flowMap[ny][nx] = dist + 1;
          queue.push({x: nx, y: ny});
        }
      }
    }
    visitedCount++;
    if(visitedCount > 1000) break; 
  }
}

/* === CONTROLS & ACTION (minor change: shots now store per-second velocities) === */
const keys = {};
let touchX = 0, touchY = 0, fireInterval = null;

const startAction = () => {
  if (!fireInterval && gameActive) {
    doAction();
    fireInterval = setInterval(doAction, FIRE_INTERVAL_MS); 
  }
};
const stopAction = () => {
  clearInterval(fireInterval);
  fireInterval = null;
};

window.addEventListener("keydown", e => {
  if(!keys[e.code]) { 
      keys[e.code] = true;
      if (e.code === "Space") startAction();
  }
});
window.addEventListener("keyup", e => {
  keys[e.code] = false;
  if (e.code === "Space") stopAction();
});

const joy = document.getElementById("joy");
const knob = document.getElementById("knob");
const actBtn = document.getElementById("act");

joy.addEventListener("touchstart", handleTouch, {passive: false});
joy.addEventListener("touchmove", handleTouch, {passive: false});
joy.addEventListener("touchend", () => {
  touchX = 0; touchY = 0;
  knob.style.transform = "translate(0,0)";
});

function handleTouch(e) {
  if (!gameActive) return;
  e.preventDefault();
  let t = e.touches[0];
  for (let i = 0; i < e.touches.length; i++) if (joy.contains(e.touches[i].target)) t = e.touches[i];
    
  let r = joy.getBoundingClientRect();
  let dx = t.clientX - (r.left + r.width / 2);
  let dy = t.clientY - (r.top + r.height / 2);
  let d = Math.min(r.width / 2, Math.hypot(dx, dy));
  let ang = Math.atan2(dy, dx);
    
  touchX = Math.cos(ang) * (d / (r.width / 2));
  touchY = Math.sin(ang) * (d / (r.width / 2));
  knob.style.transform = "translate(" + (touchX * 40) + "px," + (touchY * 40) + "px)";
}

actBtn.addEventListener("touchstart", e => {
  e.preventDefault();
  if (!gameActive) return; 
  startAction();
}, {passive: false});

actBtn.addEventListener("touchend", stopAction);
actBtn.addEventListener("touchcancel", stopAction);

function doAction() {
  player.swing = 5; 
  // create shot velocities in px/second so movement is dt-correct
  shots.push({
    x: player.x,
    y: player.y,
    dx: Math.cos(player.dir) * ARROW_SPEED_PPS,
    dy: Math.sin(player.dir) * ARROW_SPEED_PPS,
    dmg: Math.max(1, player.bowLvl)
  });
}

/* === UPDATE: now accepts dt (seconds) and uses per-second velocities === */
function update(dt) {
  if (!gameActive || gameOver) return;

  // Player movement: touch/keys produce unit direction vector; movement uses per-second speed * dt
  let mx = (keys.ArrowLeft || keys.KeyA ? -1 : keys.ArrowRight || keys.KeyD ? 1 : 0) + touchX;
  let my = (keys.ArrowUp || keys.KeyW ? -1 : keys.ArrowDown || keys.KeyS ? 1 : 0) + touchY;
    
  let m = Math.hypot(mx, my);
  if (m > 0.1) {
    mx /= m; my /= m;
    player.dir = Math.atan2(my, mx);
    let nx = player.x + mx * PLAYER_SPEED_PPS * dt;
    let ny = player.y + my * PLAYER_SPEED_PPS * dt;
    if (!isWall(nx, player.y)) player.x = Math.max(16, Math.min(WORLD - 16, nx));
    if (!isWall(player.x, ny)) player.y = Math.max(16, Math.min(WORLD - 16, ny));
  }

  // Mark explored
  let tx = Math.floor(player.x / TILE), ty = Math.floor(player.y / TILE);
  for (let y = ty - 4; y <= ty + 4; y++) {
    for (let x = tx - 4; x <= tx + 4; x++) {
      if (x >= 0 && y >= 0 && x < MAP_SIZE && y < MAP_SIZE) explored[y][x] = true;
    }
  }

  // Flow field update every ~16 frames originally => ~0.2667s; accumulate dt
  flowAccSeconds += dt;
  if (flowAccSeconds > (16 / FPS)) {
    updateFlowField();
    flowAccSeconds = 0;
  }

  // Timers: decrement by frames equivalent = dt * FPS so existing numeric frame-based values work
  if (player.swing > 0) player.swing -= dt * FPS;
  if (player.hitTimer > 0) player.hitTimer -= dt * FPS;

  // Enemy movement: compute per-frame-style speed then convert to per-second
  let settings = DIFFICULTY_SETTINGS[currentDifficulty];
  const CURRENT_ENEMY_SPEED = 4.6 + ((biomeLevel - 1) * settings.enemySpeedStep); // px/frame
  const CURRENT_ENEMY_SPEED_PPS = CURRENT_ENEMY_SPEED * FPS; // px/sec

  world.enemies.forEach(e => {
    if (e.hitTimer > 0) e.hitTimer -= dt * FPS;

    let d = Math.hypot(player.x - e.x, player.y - e.y);
    if (d < 450) { 
      let vx = 0, vy = 0;
      let etx = Math.floor(e.x / TILE);
      let ety = Math.floor(e.y / TILE);
        
      if(etx>=0 && ety>=0 && etx<MAP_SIZE && ety<MAP_SIZE) {
        let bestDist = flowMap[ety][etx];
        let bestDir = null;
        let neighbors = [
            {x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0},
            {x:-1, y:-1}, {x:1, y:-1}, {x:-1, y:1}, {x:1, y:1}
        ];
        neighbors.forEach(n => {
            let nTx = etx + n.x;
            let nTy = ety + n.y;
            if(nTx>=0 && nTy>=0 && nTx<MAP_SIZE && nTy<MAP_SIZE) {
                if(flowMap[nTy][nTx] < bestDist) {
                    bestDist = flowMap[nTy][nTx];
                    bestDir = n;
                }
            }
        });
        if (bestDir) {
           vx = bestDir.x; vy = bestDir.y;
           let vm = Math.hypot(vx, vy);
           if(vm > 0) { vx/=vm; vy/=vm; }
        } else {
           vx = (player.x - e.x)/d; vy = (player.y - e.y)/d;
        }
      }
        
      let nx = e.x + vx * CURRENT_ENEMY_SPEED_PPS * dt;
      let ny = e.y + vy * CURRENT_ENEMY_SPEED_PPS * dt;
      
      let distToPlayer = Math.hypot(nx - player.x, ny - player.y);
      if (distToPlayer > 30) {
        if (!isWall(nx, e.y)) e.x = nx;
        if (!isWall(e.x, ny)) e.y = ny;
      }
        
      if (d < (PLAYER_RAD + 20) && (e.atkDelay <= 0)) {
        let angleToEnemy = Math.atan2(e.y - player.y, e.x - player.x);
        let angleDiff = Math.abs(angleToEnemy - player.dir);
        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
        angleDiff = Math.abs(angleDiff);

        let isBackstab = angleDiff > (Math.PI / 1.5);
        let damage = e.dmg;
        if(isBackstab) {
           damage = Math.floor(damage * 1.5); 
           vibrate([50, 50, 50]); 
        } else {
           vibrate(200); 
        }

        player.hp -= damage;
        player.hitTimer = 8; // frame-based value
        e.atkDelay = 45; // frame-based value
      }
    }
    if (e.atkDelay > 0) e.atkDelay -= dt * FPS;
    
    // MELEE HIT (player.swing is decremented by dt*FPS above)
    if (player.swing > 0 && d < (PLAYER_RAD + 45)) {
      let angleToEnemy = Math.atan2(e.y - player.y, e.x - player.x);
      let diff = angleToEnemy - player.dir;
      while (diff > Math.PI) diff -= Math.PI * 2;
      while (diff < -Math.PI) diff += Math.PI * 2;

      if (Math.abs(diff) < 1.75) {
          e.hp -= Math.max(1, player.swordLvl);
          e.hitTimer = 5; 
          vibrate(40);
          if (e.hp <= 0) {
            spawnDrop(e.x, e.y);
            enemiesKilled++; 
          }
      }
    }
  });

  // Shots: dx/dy are in px/sec. Move by dx*dt.
  shots = shots.filter(s => {
    s.x += s.dx * dt;
    s.y += s.dy * dt;
    if (isWall(s.x, s.y)) return false;
    let hit = false;
    world.enemies.forEach(e => {
      if (Math.hypot(s.x - e.x, s.y - e.y) < 25) {
        e.hp -= s.dmg; hit = true;
        e.hitTimer = 5; 
        vibrate(40); 
        if (e.hp <= 0) {
           spawnDrop(e.x, e.y);
           enemiesKilled++; 
        }
      }
    });
    
    if (inDungeon && world.boss && Math.hypot(s.x - world.boss.x, s.y - world.boss.y) < 60) {
      let damage = Math.max(1, s.dmg - world.boss.defense);
      world.boss.hp -= damage; 
      hit = true;
      world.boss.hitTimer = 5; 
      player.hitTimer = 6; // slight flash when hitting boss
      vibrate(40);
    }
    return !hit && s.x > 0 && s.x < WORLD && s.y > 0 && s.y < WORLD;
  });

  world.enemies = world.enemies.filter(e => e.hp > 0);

  // BOSS LOGIC: convert speed to px/sec and use dt
  if (inDungeon && world.boss) {
    if (world.boss.hitTimer > 0) world.boss.hitTimer -= dt * FPS;

    let bd = Math.hypot(player.x - world.boss.x, player.y - world.boss.y);
    if (bd < 700) world.boss.active = true;

    if (world.boss.active) { 
      let bdx = player.x - world.boss.x;
      let bdy = player.y - world.boss.y;
      let bDist = Math.hypot(bdx, bdy);
      
      if(bDist > 0 && bDist > 75) { 
          let bossSpeed;
          if (currentDifficulty === 'impossible') {
            bossSpeed = Math.max(0.1, PLAYER_SPEED - 1.5);
          } else {
            bossSpeed = BOSS_SPEED + (settings.bossSpeedAdd || 0);
          }
          const bossSpeedPPS = bossSpeed * FPS;
          world.boss.x += (bdx / bDist) * bossSpeedPPS * dt; 
          world.boss.y += (bdy / bDist) * bossSpeedPPS * dt;
      }

      if (bd < (PLAYER_RAD + 60) && world.boss.atkDelay <= 0) {
        player.hp -= world.boss.dmg;
        player.hitTimer = 12; // frame-based
        world.boss.atkDelay = 45;
        vibrate(300);
      }
    }
    if (world.boss.atkDelay > 0) world.boss.atkDelay -= dt * FPS;
    
    if (player.swing > 0 && bd < (PLAYER_RAD + 75)) {
       let angleToBoss = Math.atan2(world.boss.y - player.y, world.boss.x - player.x);
       let diff = angleToBoss - player.dir;
       while (diff > Math.PI) diff -= Math.PI * 2;
       while (diff < -Math.PI) diff += Math.PI * 2;

       if (Math.abs(diff) < 1.75) {
          let rawDmg = Math.max(1, player.swordLvl);
          let finalDmg = Math.max(1, rawDmg - world.boss.defense);
          world.boss.hp -= finalDmg;
          world.boss.hitTimer = 5; 
          vibrate(50);
       }
    }
    
    if (world.boss.hp <= 0) {
      enemiesKilled++; 
      
      if (biomeLevel === 10 && beatGameTime === null) {
          beatGameTime = Date.now() - startTime;
          showVictoryScreen();
      } else {
          biomeLevel++;
          generateWorld(false);
      }
    }
  }

  if (!inDungeon && Math.hypot(player.x - world.entrance.x, world.entrance.y - player.y) < 40) enterDungeon();

  drops = drops.filter(d => {
    if (Math.hypot(player.x - d.x, player.y - d.y) < (PLAYER_RAD + 20)) {
      if (d.type === "hp") {
         player.hp = Math.min(player.max, player.hp + 1);
         heartsCollected++;
      }
      else if (d.type === "Sword") player.swordLvl++;
      else if (d.type === "Bow") player.bowLvl++;
      return false;
    }
    return true;
  });

  if (player.hp <= 0 && gameActive) {
      showGameOver();
  }
}

/* spawnDrop modified: triple probabilities in BEGINNER (easy), keep impossible halving */
function spawnDrop(x, y) {
  let pSword = 0.019;
  let pBow = 0.019;
  let pHp = 0.137;

  if (currentDifficulty === 'easy') {
    // Triple all drops in Beginner mode
    pSword *= 3;
    pBow *= 3;
    pHp *= 3;
  }

  if (currentDifficulty === 'impossible') {
    pSword *= 0.5;
    pBow *= 0.5;
    pHp *= 0.5;
  }

  const r = Math.random();
  if (r < pSword) {
    drops.push({ x, y, type: "Sword" });
  } else if (r < pSword + pBow) {
    drops.push({ x, y, type: "Bow" });
  } else if (r < pSword + pBow + pHp) {
    drops.push({ x, y, type: "hp" });
  }
}

/* enterDungeon unchanged semantics */
function enterDungeon() {
  inDungeon = true;
  Music.play('dungeon');
  
  explored = Array(MAP_SIZE).fill().map(() => Array(MAP_SIZE).fill(false));
  flowMap = Array(MAP_SIZE).fill().map(() => Array(MAP_SIZE).fill(9999));
  flowAccSeconds = 0;
    
  let wallChance = 0.06;

  for (let y = 0; y < MAP_SIZE; y++) {
    world.grid[y] = [];
    for (let x = 0; x < MAP_SIZE; x++) {
      let isBorder = (x === 0 || y === 0 || x === MAP_SIZE - 1 || y === MAP_SIZE - 1);
      let isWallTile = isBorder || (Math.random() < wallChance);
      world.grid[y][x] = isWallTile ? 1 : 0;
    }
  }
    
  world.enemies = []; shots = []; drops = [];
  let sp = findSafePos(); player.x = sp.x; player.y = sp.y;
  let bp = findSafePos();
    
  while (Math.hypot(bp.x - player.x, bp.y - player.y) < 600) bp = findSafePos();
  
  let settings = DIFFICULTY_SETTINGS[currentDifficulty];
  
  let hpS = biomeLevel * settings.bossHpMult; 
  let dmgS = 5 + (biomeLevel * 1.0); 
  let defS = Math.floor(biomeLevel * settings.bossDefMult); 
    
  world.boss = { 
    x: bp.x, 
    y: bp.y, 
    hp: hpS, 
    max: hpS, 
    dmg: dmgS, 
    defense: defS, 
    atkDelay: 0,
    hitTimer: 0,
    active: false 
  };
    
  let scaledDmg = 1 + Math.floor((biomeLevel - 1) * 0.25);
  let enemyCount = settings.enemyCountBase + (biomeLevel * settings.enemyCountStep);

  for (let i = 0; i < enemyCount; i++) {
    let enp = findSafePos();
    if (Math.hypot(enp.x - player.x, enp.y - player.y) > 500) {
      world.enemies.push({ 
        x: enp.x, 
        y: enp.y, 
        hp: 1, 
        dmg: scaledDmg, 
        atkDelay: 0, 
        hitTimer: 0,
        color: biomes[(biomeLevel - 1) % biomes.length].enemy
      });
    }
  }
}

/* === RENDER (draw even when paused so minimap can be tapped to resume) === */
const ctx = document.getElementById("c").getContext("2d");
const canvas = document.getElementById("c");

function draw() {
  // If there is no world yet, clear and return
  if (!world || !player) {
    ctx.fillStyle = "#000"; ctx.fillRect(0,0,canvas.width,canvas.height);
    return;
  }

  const b = biomes[(biomeLevel - 1) % biomes.length];
  let cx = player.x - 400, cy = player.y - 300;

  ctx.fillStyle = "#000"; ctx.fillRect(0, 0, canvas.width, canvas.height);

  let startX = Math.max(0, Math.floor(cx / TILE));
  let endX = Math.min(MAP_SIZE, startX + 27);
  let startY = Math.max(0, Math.floor(cy / TILE));
  let endY = Math.min(MAP_SIZE, startY + 20);

  for (let y = startY; y < endY; y++) {
    for (let x = startX; x < endX; x++) {
      let drawX = x * TILE - cx;
      let drawY = y * TILE - cy;

      if (world.grid[y][x] === 1) {
        ctx.fillStyle = b.wall; 
        ctx.fillRect(drawX, drawY, TILE, TILE);
        
        ctx.fillStyle = "rgba(255,255,255,0.2)";
        ctx.fillRect(drawX, drawY, TILE, 4);
        ctx.fillRect(drawX, drawY, 4, TILE);
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.fillRect(drawX + TILE - 4, drawY, 4, TILE);
        ctx.fillRect(drawX, drawY + TILE - 4, TILE, 4);
        
        ctx.strokeStyle = b.wallEdge; 
        ctx.strokeRect(drawX, drawY, TILE, TILE);

      } else if (!inDungeon) {
        ctx.fillStyle = b.grass; 
        ctx.fillRect(drawX, drawY, TILE, TILE);
        
        let noise = ((x * 13 + y * 23) % 10) / 10;
        if (noise > 0.6) {
           ctx.fillStyle = "rgba(0,0,0,0.1)";
           ctx.fillRect(drawX + 8, drawY + 8, 4, 4);
        }
        if (noise < 0.3) {
           ctx.fillStyle = "rgba(255,255,255,0.1)";
           ctx.fillRect(drawX + 20, drawY + 18, 2, 2);
           ctx.fillRect(drawX + 4, drawY + 22, 2, 2);
        }

      } else {
        ctx.fillStyle = "#111"; 
        ctx.fillRect(drawX, drawY, TILE, TILE);
        
        if ((x + y) % 2 === 0) {
            ctx.fillStyle = "rgba(255,255,255,0.03)";
            ctx.fillRect(drawX + 2, drawY + 2, TILE - 4, TILE - 4);
        }
        if ((x * y) % 11 === 0) {
             ctx.fillStyle = "#0a0a0a";
             ctx.fillRect(drawX + 8, drawY + 8, TILE-16, TILE-16);
        }
      }
    }
  }

  if (!inDungeon) {
    ctx.fillStyle = "#000"; ctx.beginPath();
    ctx.arc(world.entrance.x - cx, world.entrance.y - cy, 35, 0, Math.PI*2);
    ctx.fill(); ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.stroke();
  }

 // PLAYER
ctx.save();
if (player.hitTimer > 0) {
  ctx.shadowBlur = 36;
  ctx.shadowColor = "rgba(255,255,255,0.95)";
  ctx.fillStyle = "#ffffff";
} else {
  ctx.shadowBlur = 18;
  ctx.shadowColor = player.glowColor || "rgba(0,180,255,0.75)";
  ctx.fillStyle = "#3498db";
}
ctx.beginPath();
ctx.arc(400, 300, PLAYER_RAD, 0, Math.PI * 2);
ctx.fill();
ctx.lineWidth = 2;
ctx.strokeStyle = player.hitTimer > 0 ? "rgba(255,255,255,0.9)" : "rgba(255,255,255,0.8)";
ctx.stroke();
ctx.restore();

  if (player.swing > 0) {
    ctx.save();
    ctx.shadowBlur = 20; ctx.shadowColor = "rgba(0,180,255,0.75)";
    ctx.strokeStyle = "rgba(255,255,255,0.6)"; ctx.lineWidth = 20; ctx.beginPath();
    ctx.arc(400, 300, PLAYER_RAD + 25, player.dir - 1.75, player.dir + 1.75); ctx.stroke();
    ctx.restore();
  }

  world.enemies.forEach(e => {
    ctx.save();
    if (e.hitTimer > 0) {
      ctx.fillStyle = "#fff";
      ctx.shadowBlur = 0;
    } else {
      ctx.fillStyle = b.enemy;
      ctx.shadowColor = e.color || b.enemy;
      ctx.shadowBlur = 12;
    }
    ctx.strokeStyle = "#000"; ctx.lineWidth = 1;
    
    ctx.beginPath(); ctx.arc(e.x - cx, e.y - cy, 14, 0, Math.PI*2); 
    ctx.fill(); ctx.stroke();
    ctx.restore();

    if (e.hitTimer === 0) {
        ctx.fillStyle = "#000"; 
        ctx.fillRect(e.x - cx - 5, e.y - cy - 5, 3, 3);
        ctx.fillRect(e.x - cx + 2, e.y - cy - 5, 3, 3);
    }
  });

  if (inDungeon && world.boss) {
    let bx = world.boss.x - cx, by = world.boss.y - cy;
    ctx.fillStyle = (world.boss.hitTimer > 0) ? "#fff" : b.enemy;
    ctx.beginPath(); ctx.arc(bx, by, 50, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = "#fff"; ctx.lineWidth = 3; ctx.stroke();
      
    ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(bx - 52, by - 82, 104, 14);
    ctx.fillStyle = "#333"; ctx.fillRect(bx - 50, by - 80, 100, 10);
    ctx.fillStyle = "#ff0000"; ctx.fillRect(bx - 50, by - 80, (world.boss.hp / world.boss.max) * 100, 10);
  }

  // DRAW SHOTS (positions updated in update(dt))
  shots.forEach(s => {
    ctx.strokeStyle = "#f1c40f"; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(s.x - cx, s.y - cy);
    // draw a little trail backwards scaled by current per-second velocity magnitude (approx)
    ctx.lineTo(s.x - cx - (s.dx / FPS) * 2, s.y - cy - (s.dy / FPS) * 2); ctx.stroke();

    // Draw shaft + diamond (unchanged visuals)
    ctx.fillStyle = "#bdc3c7"; 
    let ang = Math.atan2(s.dy, s.dx);
    ctx.save();
    ctx.translate(s.x - cx, s.y - cy);
    ctx.rotate(ang);

    // Shaft extended so its end touches the diamond head
    ctx.beginPath();
    ctx.rect(-18, -1.5, 28, 3);
    ctx.fill();

    // Diamond arrowhead with glow
    ctx.save();
    ctx.shadowBlur = 20; ctx.shadowColor = "rgba(0,180,255,0.75)";
    ctx.beginPath();
    ctx.fillStyle = "#dfeef6";
    ctx.moveTo(10, 0);
    ctx.lineTo(14, -5);
    ctx.lineTo(18, 0);
    ctx.lineTo(14, 5);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 1;
    ctx.stroke();

    ctx.shadowBlur = 0;
    ctx.fillStyle = "rgba(255,255,255,0.8)";
    ctx.arc(14, 0, 1.2, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.restore();
  });

  // DROPS (unchanged visuals)
  drops.forEach(d => {
    let dx = d.x - cx, dy = d.y - cy;
    if (d.type === "hp") {
      ctx.save();
      ctx.shadowBlur = 20; ctx.shadowColor = "rgba(0,180,255,0.75)";
      ctx.fillStyle = "#3498db"; ctx.strokeStyle = "#fff"; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(dx, dy, 10, 0, Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.fillStyle = "rgba(255,255,255,0.7)"; 
      ctx.beginPath(); ctx.arc(dx-3, dy-3, 3, 0, Math.PI*2); ctx.fill();
      ctx.restore(); 

    } else if (d.type === "Sword") {
      ctx.save();
      ctx.shadowBlur = 20; ctx.shadowColor = "rgba(0,180,255,0.75)";
      ctx.translate(dx, dy);
      ctx.rotate(Math.PI / 4);
      ctx.strokeStyle = "#ffffff"; ctx.lineWidth = 2; ctx.lineJoin = "round";
      ctx.beginPath(); 
      ctx.moveTo(-3, -15); ctx.lineTo(3, -15); ctx.lineTo(0, -22); ctx.lineTo(-3, -15);
      ctx.rect(-3, -15, 6, 24);
      ctx.stroke();
      ctx.fillStyle = "#dfeef6"; ctx.fillRect(-3, -15, 6, 24); 
      ctx.beginPath(); ctx.moveTo(-3, -15); ctx.lineTo(3, -15); ctx.lineTo(0, -22); ctx.fill();
      ctx.fillStyle = "#f39c12"; ctx.fillRect(-8, 5, 16, 4);
      ctx.fillStyle = "#8e44ad"; ctx.fillRect(-2, 9, 4, 8);
      ctx.restore();

    } else if (d.type === "Bow") {
      ctx.save();
      ctx.translate(dx, dy);
      ctx.rotate(-Math.PI / 4);

      // Draw bow wood with glow
      ctx.shadowBlur = 20; ctx.shadowColor = "rgba(0,180,255,0.75)";
      ctx.strokeStyle = "#deb887"; 
      ctx.lineWidth = 4; ctx.lineCap = "round"; 
      ctx.beginPath();
      ctx.moveTo(0, -5); 
      ctx.quadraticCurveTo(-15, -10, -10, -20);
      ctx.moveTo(0, 5);
      ctx.quadraticCurveTo(-15, 10, -10, 20);
      ctx.stroke();

      // Draw bow string with glow
      ctx.beginPath();
      ctx.shadowBlur = 20; ctx.shadowColor = "rgba(0,180,255,0.75)";
      ctx.strokeStyle = "#00b4ff"; ctx.lineWidth = 3;
      ctx.moveTo(0, -5); ctx.lineTo(0, 5); ctx.stroke();

      // Draw grip over string
      ctx.shadowBlur = 0;
      ctx.strokeStyle = "#8d6e63"; ctx.lineWidth = 5;
      ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(0, 5); ctx.stroke();

      ctx.restore();
    }
  });

  // STATS BOX + MINIMAP (unchanged)
  const boxX = 20;
  const boxY = 10;
  const boxW = 360;
  const boxH = 110;

  ctx.fillStyle = "rgba(0,0,0,0.72)";
  ctx.fillRect(boxX, boxY, boxW, boxH);
  ctx.strokeStyle = "#ffffff";
  ctx.lineWidth = 2;
  ctx.strokeRect(boxX, boxY, boxW, boxH);

  ctx.fillStyle = "#ffffff";
  ctx.textAlign = "left";
  ctx.font = "bold 18px monospace";
  ctx.fillText("HP: " + Math.ceil(player.hp), boxX + 12, boxY + 36);

  ctx.font = "14px monospace";
  ctx.fillText("Sword Lvl: " + player.swordLvl, boxX + 12, boxY + 62);
  ctx.fillText("Bow Lvl: " + player.bowLvl, boxX + 12, boxY + 88);

  ctx.textAlign = "right";
  ctx.font = "bold 16px monospace";
  // Show elapsed time, but freeze during pause
  const displayTime = pauseTimestamp > 0 ? (pauseTimestamp - startTime) : (Date.now() - startTime);
  ctx.fillText("TIME: " + formatTime(displayTime), boxX + boxW - 12, boxY + 36);
  ctx.fillStyle = "#aaaaaa";
  ctx.font = "13px monospace";
  ctx.fillText("DIFF: " + (DIFFICULTY_SETTINGS[currentDifficulty]?.name || currentDifficulty).toUpperCase(), boxX + boxW - 12, boxY + 62);

  ctx.textAlign = "right";
  ctx.fillStyle = "#ffffff";
  ctx.font = "bold 15px monospace";
  ctx.fillText("BIOME " + biomeLevel + ": " + b.name.toUpperCase(), boxX + boxW - 6, boxY + 92);
  ctx.globalAlpha = 1.0;

  const mmS = 1.0;
  const mmX = 650;
  const mmY = 15;
  const mmW = MAP_SIZE * mmS;
  const mmH = MAP_SIZE * mmS;

  ctx.globalAlpha = 0.8; ctx.fillStyle = "#000";
  ctx.fillRect(mmX, mmY, mmW, mmH);
  
  // Add translucent gray outline
  ctx.strokeStyle = "rgba(128,128,128,0.5)";
  ctx.lineWidth = 2;
  ctx.strokeRect(mmX, mmY, mmW, mmH);
  
  for (let y = 0; y < MAP_SIZE; y++) {
    for (let x = 0; x < MAP_SIZE; x++) {
      if (explored[y][x]) {
        ctx.fillStyle = world.grid[y][x] === 1 ? b.wall : "#2a2a2a";
        ctx.fillRect(mmX + x * mmS, mmY + y * mmS, mmS, mmS);
      }
    }
  }

  if (!inDungeon) {
    let ex = Math.floor(world.entrance.x / TILE);
    let ey = Math.floor(world.entrance.y / TILE);
    if (explored[ey] && explored[ey][ex]) {
        ctx.fillStyle = b.enemy;
        ctx.beginPath();
        ctx.arc(mmX + ex * mmS, mmY + ey * mmS, 3, 0, Math.PI*2);
        ctx.fill();
    }
  }

  ctx.fillStyle = "#00ffff"; ctx.beginPath();
  ctx.arc(mmX + (player.x / TILE) * mmS, mmY + (player.y / TILE) * mmS, 2.5, 0, Math.PI*2);
  ctx.fill(); ctx.globalAlpha = 1.0;
}

/* === MAIN LOOP: compute dt and pass to update === */
let lastTime = performance.now();
(function loop(now) {
  const dt = Math.min(0.1, (now - lastTime) / 1000); // clamp to avoid huge jumps (max 100ms)
  lastTime = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
})(lastTime);

/* === Visibility / Focus handling: pause when app/backgrounded === */
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    // Pause when backgrounded and show overlay
    if (gameActive && gameRunning && !gameOver) {
      pauseGame(true);
    }
  } else {
    // When returning to visible, keep the overlay shown if game is paused
    // User will tap the map to resume
  }
});
window.addEventListener('blur', () => {
  // Pause when window loses focus
  if (gameActive && gameRunning && !gameOver) {
    pauseGame(true); // Show overlay so user knows to tap map when returning
  }
});
window.addEventListener('focus', () => {
  // When focus returns, keep overlay shown if game is paused
  // User will tap the map to resume
});

/* Canvas click/touch: handle minimap pause/unpause */
function getCanvasPos(e) {
  const rect = canvas.getBoundingClientRect();
  let clientX, clientY;
  if (e.touches && e.touches[0]) {
    clientX = e.touches[0].clientX;
    clientY = e.touches[0].clientY;
  } else {
    clientX = e.clientX;
    clientY = e.clientY;
  }
  const x = (clientX - rect.left) * (canvas.width / rect.width);
  const y = (clientY - rect.top) * (canvas.height / rect.height);
  return {x, y};
}

canvas.addEventListener('click', (e) => {
  const pos = getCanvasPos(e);
  const mmX = 650, mmY = 15, mmW = MAP_SIZE, mmH = MAP_SIZE;
  if (pos.x >= mmX && pos.x <= mmX + mmW && pos.y >= mmY && pos.y <= mmY + mmH) {
    togglePauseByMap();
  }
});

canvas.addEventListener('touchstart', (e) => {
  const pos = getCanvasPos(e);
  const mmX = 650, mmY = 15, mmW = MAP_SIZE, mmH = MAP_SIZE;
  if (pos.x >= mmX && pos.x <= mmX + mmW && pos.y >= mmY && pos.y <= mmY + mmH) {
    e.preventDefault();
    togglePauseByMap();
  }
}, {passive: false});
</script>
</body>
</html>
